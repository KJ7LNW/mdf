#!/usr/bin/perl

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Library General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#  Copyright (C) 2022- by Ezekiel Wheeler, KJ7NLL and Eric Wheeler, KJ7LNW.
#  All rights reserved.
#
#  Octopart is a registered trademark and brand of Octopart, Inc.
#
#  All tradmarks, product names, logos, and brands are property of their
#  respective owners and no grant or license is provided thereof.
#
#  The copyright below applies to this software module; the copyright holder is
#  unaffiliated with Octopart, Inc.

use strict;
use warnings;
use Carp;

use Term::ANSIColor;
use Getopt::Long qw(:config bundling);
use Data::Dumper;

use RF::Component;
use RF::Component::Multi;

use API::Octopart;

my %opts;

# Defaults:
$opts{verbose} = 0;
$opts{unique} = 1;
$opts{octopart_show_stock} = 0;

GetOptions(
	"var-code|V=s"		=> \$opts{var_code},
	"var-literal|L=s"	=> \$opts{var_literal},
	"var-name|n=s"		=> \$opts{var_name},
	"unique|u"		=> sub { $opts{unique} = 1 },
	"not-unique|U"		=> sub { $opts{unique} = 0 },
	"sort|s=s"		=> \$opts{sort},
	"mdif-var-format|c=s"	=> \$opts{var_format},
	"freqs|f=s"		=> \$opts{freqs},
	"reverse_sort|r"	=> \$opts{reverse_sort}, 
	"limit|l=s"		=> \$opts{limit},
	"verbose|v"		=> sub {$opts{verbose}++},
	"quiet|q"		=> \$opts{quiet},
	"output|o=s"		=> \$opts{output},
	"model-suffix|m=s"	=> \$opts{model_suffix},
	"octopart|O"		=> \$opts{octopart},
	"octopart-filter|F=s"	=> \$opts{octopart_filter},
	"octopart-include-specs|I" => \$opts{octopart_specs},
	"octopart-show-stock|S"	=> sub{ $opts{octopart_show_stock}++ },
) or usage();

usage() if ( !@ARGV );
usage("output must be specified") if ( !$opts{output} );
usage("cannot specify both --var-code and --var-literal") if ( $opts{var_code} && $opts{var_literal});

$opts{sort} //= 'reactance[0]';

my $octo;
my %octo_filter;

if ($opts{octopart_filter})
{
	$opts{octopart} = 1;
	%octo_filter = map { split /\s*=\s*/ } split(/\s*,\s*/, $opts{octopart_filter})
}

if ($opts{octopart})
{
	$octo = API::Octopart->new(
		token => (sub { my $t = `cat ~/.octopart/token`; chomp $t; return $t})->(),
		cache => "$ENV{HOME}/.octopart/cache",
		include_specs => $opts{octopart_specs},
		ua_debug => 0,
		);
}

my @all_components;

my $count = 0;
foreach my $file (@ARGV)
{
	my ( $value_unit, %v);

	last if (defined($opts{limit}) && ++$count > $opts{limit});

	@v{'value_unit', 'value_code_regex'} = split(/[=]/, $opts{var_code}) if ($opts{var_code});
	@v{'value_unit', 'value_literal_regex'} = split(/[=]/, $opts{var_literal}) if ($opts{var_literal});
	$v{filename} = $file;

	$opts{var_name} //= $v{value_unit};

	my $comp = eval { RF::Component->load($file, %v) };
	warn $@ if !$comp;

	print STDERR colored(['red bold'], $@) if $@;

	next if !$comp;

	push @all_components, $comp;
}

# Keep these sorted in @ARGV order because we want to select
# files based on tolerance order.
# For example: GQM1555C2D???{W,B,C,D,F,G,J,K,M}*.s2p
my %seen;
my @available_components;
foreach my $c (@all_components)
{
	my %vars;

	my $stock = get_stock($c);
	my $model = $c->model;
	my $val = var_eval_func($c, $opts{sort});
	my $var_format = var_format($c);

	# Perl will evaluate this nonzero-length string as "true", below.
	$stock //= 'unknown';

	if ($stock)
	{
		if ($val)
		{
			# skip to the next file if already seen:
			next if ($opts{unique} && $seen{$val});

			$seen{$val}++;
		}

		if ($opts{verbose} >= 2)
		{
			print STDERR colored(['green bold'], "$model ($var_format): $stock in stock\n")
		}

		push @available_components, $c;
	}
	elsif ($opts{verbose} >= 3)
	{
		print STDERR colored(['red bold'], "$model ($var_format): $stock in stock\n");
	}
}

my $out;
if ($opts{output} eq '-')
{
	$out = *STDOUT;
}
else
{
	open($out, ">", $opts{output}) or die "$opts{output}: $!";
}

my $idx = 0;
my %seller_counts;
my %part_models;

use PDL;
my @sorted_components =
	sort { var_eval_func($a, $opts{sort}) <=> var_eval_func($b, $opts{sort}) }
		@available_components;

@sorted_components = reverse @sorted_components if ($opts{reverse_sort});

# Save in magnitude-angle format, but only so `diff` shows me how well the output works.
# You can use any format you like: db, ma, ri.
my $mdf = RF::Component::Multi->new(@sorted_components);
$mdf->save($opts{output}, save_options => {format => 'MA'}, vars =>
	{
		($opts{var_name} // 'component') => sub { our $i //= 0; var_format(shift, idx => $i++) }
	});

if ($opts{verbose} >= 1)
{
	my $count = @sorted_components;
	print STDERR colored(['blue bold'], "Added $count parts to $opts{output}\n");
}

if ($opts{octopart_show_stock} >= 1)
{
	foreach my $s (sort { $seller_counts{$b} <=> $seller_counts{$a} } keys %seller_counts)
	{
		print STDERR colored(['cyan'],
			"$seller_counts{$s} parts are available through $s\n");
	}
}

close($out);

if ($opts{verbose} >= 1)
{
	if ($opts{octopart})
	{
		print STDERR colored(['white'],
			"Octopart.com API queries: " . $octo->octo_query_count() . "\n")
	}
	else
	{
		print STDERR colored(['white bold'], "Octopart.com API queries are not enabled\n");
	}
}

#print Dumper(\%files);

exit 0;

##############################################################################
# Functions

sub usage
{
	my $err = shift;
	croak colored [ qw/red bold/], "$err" if $err;

	print "usage: $0 [options] --var-code 'var_name=MODEL-(...)\.s2p' file1.s2p [file2...] -o mymdf.mdf

--output|-o      <file>        Output filename, required.
	If the filename is '-' then output will be written to stdout

Note that regular expressions matching filenames are always case-insensitive:

--var-code|-V    <regex>       Either of --var-code or --var-literal are required.
	Specifies the variable to be assigned and a regular expression to match
	the capacitance code (or other unit): NNX or NRN. X is the exponent, N
	is a numeric value.

	If a capacitor code is 111 then it will calculate 11*10^1 == 110 pF.  A
	code of 1N4 or 14N would be 1.4 or 14.0, respectively. The unit 'pF' in
	the example is excluded from the code.

	The (...) below must match the code or literal to be placed in the MDF
	variable. Example:
		--var-code 'C_pF=MODEL-(...)\.s2p'
	
--var-literal|-L <regex>       Either of --var-code or --var-literal are required.
	The var-literal version is the same as --var-code but does not
	calcualte the code, it takes the value verbatim.  For example, some
	inductors specify the number of turns in their s2p filename:
		--var-literal 'L_turns=MODEL-([0-9]+)T\.s2p'

--reverse-sort|-r              Sort MDF values in reverse.

--not-unique|-U                Make values NOT unique
--unique|-u                    Make values unique (default)
	Choose only the first matching code if multiple of the same code are
	found.  Note that file ordering may be relevant when using the --unique
	constraint:

	If you wish to prioritize the tolerance code (or other coded metric)
	then order the file list in tolerance order.  So long as the names are
	the same except the tolerance code you could glob the tolerance code
	with braces ordered by tolerance as follows:

		GQM1555C2D???{B,C}*.s2p

	Where '???' is the value code, 'B' is +/- 0.1pF and 'C' is +/- 0.25pF
	for this example muRata part. (Note that [BC] style globbing does not
	work because the charectar class does not enforce ordering, nor does it
	support multi-charectar codes.)

	According to the muRata part guide the tolerance codes this glob lists
	in ascending order:
		GQM1555C2D???{W,B,C,D,F,G,J,K,M}*.s2p
		[ https://search.murata.co.jp/Ceramy/image/img/A01X/partnumbering_e_01.pdf ]

	Of course this technique can be used for any S2P component and is not
	specific to the manufacturer or type of component (L, C, R, etc).
	Refer to your manufacturer's documentation to choose the right
	tolerance ordering for your application.

--model-suffix|-m <suffix>  Append a string to each model

	It may be useful to append a string to the filename model when querying
	Octopart.  For example, if the Coilcraft filename is 0402-DC7N6 then a
	model-suffix of 'XG' would indicate a 2% tolerance instead of the 'XJ'
	which is a 5% tolerance.

	This string is also added to the VAR line in the .mdf.

--octopart|-O               Enable Octopart stock querying
	You will need to place your API token in ~/.octopart/token .  Queries are
	cached in ~/.octopart/cache/ to minimize redundant API requests but you
	may wish to clear that directory out periodically since stock numbers will
	become stale.

	Get your API token here: https://octopart.com/api

--octopart-filter|-F <filter_opts>    This option implies -O.
	The <filter_opts> are comma-separated values passed to the
	API::Octopart class.  These are common filter options to remember:

		min_qty=<n>    - Minimum stock quantity, per vendor.

		max_moq=<n>    - Maximum \"minimum order quantity\"
			This is the max MOQ you will accept as being in
			stock.  For example, a 5000-part reel might be more
			than you want for prototyping so set this to 10 or
			100.

		seller=<regex> - Seller's name (regular expression)
			This is a regular expression so something like
			'Mouser|Digi-key' is valid.

		mfg=<regex>    - Manufacturer name (regular expression)
			Specifying the mfg name is useful if your part model
			number is similar to those of other manufacturers.

		currency=<s>   - 'USD' for US dollars
			Defaults to include all currencies

	Example: $0 -O -F 'max_moq=100,min_qty=10,seller=Mouser|Digi-key'	

	See `perldoc API::Octopart` (or perldoc lib/API/Octopart.pm) for details.

--octopart-include-specs|-I Request product specs in the API call.
	Currently $0 does not do anything with product specs, but if you have
	an Octopart PRO account then you can enable this option ;)

--octopart-show-stock|-S    Show stock summaries
	Calling this option more than once increases the stock detail.  A
	single -S shows final summary and two -SS shows per-product per-seller
	stock detail.

--limit|-l    <N>           Limit number of file evaluations to N.
	This is useful for debugging your regex with -vvv.  Glob all the files
	you want but limit to N so you only make a few Octopart queries while
	testing.

--verbose|-v                Multiple -v's increase verbosity.
	At least 4x -v's will print detailed Octopart responses.

--quiet|-q                  Suppress warnings, but does not suppress verbosity.
\n";


	exit 1;
}

sub get_model
{
	my $component = shift;

	my $m = $component->model;
	$m .= $opts{model_suffix} // '';

	return $m;
}

sub Warn
{
	my ($file, @msg) = @_;

	return if $opts{quiet};

	# Strip the path if verbose <3
	$file =~ s!^.*/!! if ($opts{verbose} < 3);

	print STDERR colored(['yellow bold'], "$file: " . join("\n", @msg)) . "\n";
}

sub get_stock
{
	my $c = shift;
	my $model = get_model($c);

	my $stock;
	if ($opts{octopart})
	{
		$stock = $octo->has_stock($model, %octo_filter);
		if ($opts{verbose} >= 4)
		{
			print STDERR colored(['white bold'], "$model:\n\t") .
				colored(['blue'],
					Dumper($octo->get_part_stock_detail($model, %octo_filter)) . "\n");
		}
	}

	return $stock;
}

# Convert formatted strings like {reactance} or {srf/1e6} to values.  For example:
#    '{idx}. {value}{value_unit} X={reactance[0]} SRF={srf/1e9}GHz {model}'
# becomes
#    '0. 1pF X=-2209.80792664007 SRF=?GHz GRM1555C1H1R0WA01'
sub var_format
{
	my ($c, %vars) = @_;
	my $f = $opts{var_format};

	while ($f =~ /\{([^}]+)\}/g)
	{
		my $func = $1;

		my $value = var_eval_func($c, $func, %vars);

		$f =~ s/\{\Q$func\E\}/$value/g;
	}

	# Collapse multiple whitespaces to a single space:
	$f =~ s/\s+/ /g;

	return $f;
}

sub var_eval_func
{
	my ($c, $func, %vars) = @_;

	our $N //= qr/([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)/;

	# idx is always defined.
	$vars{idx} //= '?';

	my $c2 = $c->at($opts{freqs});

	my ($format_spec, $func_op);
	$func =~ s/\s+//g;
	if ($func =~ /^(%[^:]+:)?(\w+)(.*$)/ && length($2))
	{
		($format_spec, $func, $func_op) = ($1, $2, $3);
		$format_spec =~ s/:// if $format_spec;
		$func_op //= '';
	}

	my $value;
	if (defined $vars{$func})
	{
		$value = $vars{$func};
	}
	else
	{
		$value = $c2->$func;
	}

	# Couldn't find it, return '?'
	return '?' if (!defined($value));

	if (ref($value) eq 'PDL')
	{
		# Get the index if they asked for one:
		if ($func_op =~ /\[(\d+)\]/)
		{
			$value = $value->slice($1);
		}
		else
		{
			# Get an average if >1 element:
			$value = $value->sum / $value->nelem if $value->nelem > 1;
		}

		$value = $value->sclr;
	}

	$value /= $1 if ($func_op =~ m!\/($N)!);
	$value *= $1 if ($func_op =~ m!\*($N)!);

	if ($format_spec)
	{
		$value = sprintf($format_spec, $value);
	}

	return $value;
}
